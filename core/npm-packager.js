/**
 * Universal MCP Generator - NPM Packager & Config Updater
 * Creates complete NPM packages and updates Claude Desktop config
 */

import fs from 'fs/promises';
import path from 'path';
import os from 'os';
import dotenv from 'dotenv';
dotenv.config();

export class NPMPackager {
  constructor(config = {}) {
    const baseDir = process.env.MCP_BASE_DIR || path.join(os.homedir(), 'Desktop/universal-mcp-generator');
    this.templatesDir = config.templatesDir || path.join(baseDir, 'templates');
    this.outputDir = config.outputDir || path.join(baseDir, 'generated');
  }

  /**
   * Create complete NPM package from generated tools
   */
  async createPackage(siteName, toolsData, pipeline) {
    try {
      const packageName = `${siteName}-mcp`;
      const packageDir = path.join(this.outputDir, packageName);

      console.error(`üì¶ Creating NPM package: ${packageName}`);

      // Create package directory
      await fs.mkdir(packageDir, { recursive: true });

      // Generate package.json
      await this.generatePackageJson(packageDir, packageName, siteName, toolsData);

      // Generate main server file
      await this.generateServerFile(packageDir, siteName, toolsData, pipeline);

      // Generate README
      await this.generateReadme(packageDir, packageName, siteName, toolsData);

      console.error(`‚úÖ Package created: ${packageDir}`);

      return {
        success: true,
        packageName,
        path: packageDir,
        toolCount: toolsData.totalTools,
        serverPath: path.join(packageDir, 'server.js')
      };

    } catch (error) {
      console.error(`‚ùå Package creation failed: ${error.message}`);
      return { success: false, error: error.message };
    }
  }

  /**
   * Generate package.json for the MCP package
   */
  async generatePackageJson(packageDir, packageName, siteName, toolsData) {
    const packageJson = {
      name: packageName,
      version: '1.0.0',
      description: `MCP server for ${siteName} automation - Auto-generated by Universal MCP Generator`,
      main: 'server.js',
      type: 'module',
      scripts: {
        start: 'node server.js',
        dev: 'node --watch server.js'
      },
      keywords: ['mcp', 'automation', siteName.toLowerCase(), 'universal-mcp-generator'],
      author: 'Tyler Bessire via Universal MCP Generator',
      license: 'MIT',
      dependencies: {
        '@modelcontextprotocol/sdk': '^0.5.0',
        'playwright': '^1.40.0'
      },
      engines: { node: '>=18.0.0' },
      generated: {
        timestamp: new Date().toISOString(),
        tools: toolsData.totalTools,
        generator: 'Universal MCP Generator v1.0.0'
      }
    };

    await fs.writeFile(path.join(packageDir, 'package.json'), JSON.stringify(packageJson, null, 2));
  }

  /**
   * Generate main server file
   */
  async generateServerFile(packageDir, siteName, toolsData, pipeline) {
    const serverCode = `#!/usr/bin/env node
/**
 * ${siteName.toUpperCase()} MCP Server - Auto-generated
 * Generated: ${new Date().toISOString()}
 * Tools: ${toolsData.totalTools} | URL: ${pipeline.url}
 */

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { CallToolRequestSchema, ListToolsRequestSchema } from '@modelcontextprotocol/sdk/types.js';
import { chromium } from 'playwright';

class ${this.capitalize(siteName)}MCPServer {
  constructor() {
    this.server = new Server({ name: '${siteName}-mcp-server', version: '1.0.0' }, { capabilities: { tools: {} } });
    this.browser = null;
    this.page = null;
    this.baseUrl = '${pipeline.url}';
    this.setupToolHandlers();
  }

  setupToolHandlers() {
    this.server.setRequestHandler(ListToolsRequestSchema, async () => ({
      tools: ${JSON.stringify(toolsData.tools.map(tool => ({
        name: tool.name,
        description: tool.description,
        inputSchema: tool.inputSchema
      })), null, 8)}
    }));

    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      const { name, arguments: args } = request.params;
      try {
        switch (name) {
          ${toolsData.tools.map(tool => `case '${tool.name}': return await this.${this.methodName(tool.name)}(args);`).join('\n          ')}
          default: throw new Error(\`Unknown tool: \${name}\`);
        }
      } catch (error) {
        return { content: [{ type: 'text', text: \`‚ùå Error: \${error.message}\` }] };
      }
    });
  }

  async initializeBrowser() {
    if (!this.browser) {
      this.browser = await chromium.launch({ headless: false });
      this.page = await this.browser.newPage();
      await this.page.goto(this.baseUrl);
    }
    return this.page;
  }

  ${toolsData.tools.map(tool => this.generateToolMethod(tool, siteName)).join('\n\n  ')}

  async cleanup() {
    if (this.browser) {
      await this.browser.close();
      this.browser = null;
    }
  }

  async run() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.error('üöÄ ${siteName.toUpperCase()} MCP Server started');
  }
}

const server = new ${this.capitalize(siteName)}MCPServer();
server.run().catch(console.error);
process.on('SIGINT', async () => { await server.cleanup(); process.exit(0); });
`;

    await fs.writeFile(path.join(packageDir, 'server.js'), serverCode);
  }

  /**
   * Generate tool method implementations
   */
  generateToolMethod(tool, siteName) {
    const methodName = this.methodName(tool.name);
    
    if (tool.implementation === 'navigate_and_initialize') {
      return `async ${methodName}(args) {
    await this.initializeBrowser();
    return { content: [{ type: 'text', text: \`‚úÖ Initialized \${this.baseUrl}\` }] };
  }`;
    }
    
    if (tool.implementation === 'take_screenshot') {
      return `async ${methodName}(args) {
    const page = await this.initializeBrowser();
    const filename = args.filename || '${siteName}_screenshot.png';
    await page.screenshot({ path: \`/Users/tylerbessire/Desktop/\${filename}\` });
    return { content: [{ type: 'text', text: \`üì∏ Screenshot saved: \${filename}\` }] };
  }`;
    }

    if (tool.implementation === 'get_page_status') {
      return `async ${methodName}(args) {
    const page = await this.initializeBrowser();
    const title = await page.title();
    const url = page.url();
    return { content: [{ type: 'text', text: \`üìÑ Page: \${title}\\nüåê URL: \${url}\` }] };
  }`;
    }

    if (tool.implementation === 'click_element') {
      return `async ${methodName}(args) {
    const page = await this.initializeBrowser();
    await page.click('${tool.selector || 'button'}');
    return { content: [{ type: 'text', text: '‚úÖ Element clicked successfully' }] };
  }`;
    }

    // Default implementation
    return `async ${methodName}(args) {
    const page = await this.initializeBrowser();
    return { content: [{ type: 'text', text: 'üîß ${tool.description} - Implementation needed' }] };
  }`;
  }

  /**
   * Generate README file
   */
  async generateReadme(packageDir, packageName, siteName, toolsData) {
    const readme = `# ${packageName}

Auto-generated MCP server for ${siteName} automation.

## Generated Tools (${toolsData.totalTools})

${toolsData.tools.map(tool => `### ${tool.name}
${tool.description}

\`\`\`json
${JSON.stringify(tool.inputSchema, null, 2)}
\`\`\`
`).join('\n')}

## Installation

\`\`\`bash
cd ${packageName}
npm install
npm start
\`\`\`

## Claude Desktop Configuration

\`\`\`json
{
  "${siteName}-automation": {
    "command": "node",
    "args": ["${path.join(packageDir, 'server.js')}"]
  }
}
\`\`\`

Generated by Universal MCP Generator - ${new Date().toISOString()}
`;

    await fs.writeFile(path.join(packageDir, 'README.md'), readme);
  }

  capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  methodName(toolName) {
    return toolName.replace(/[^a-zA-Z0-9]/g, '_').replace(/_+/g, '_');
  }
}

/**
 * Universal MCP Generator - Config Updater
 * Updates Claude Desktop config using AppleScript
 */
export class ConfigUpdater {
  constructor() {
    this.configPath = '/Users/tylerbessire/Library/Application Support/Claude/claude_desktop_config.json';
  }

  /**
   * Add generated package to Claude Desktop config
   */
  async addToClaudeDesktop(siteName, packageResult) {
    try {
      console.error('üîß Updating Claude Desktop config...');

      // Read current config
      const currentConfig = await this.readCurrentConfig();
      
      // Add new MCP server
      const newServerConfig = {
        command: 'node',
        args: [packageResult.serverPath],
        env: {}
      };

      currentConfig.mcpServers = currentConfig.mcpServers || {};
      currentConfig.mcpServers[`${siteName}-automation`] = newServerConfig;

      // Write updated config using AppleScript
      await this.writeConfigViaAppleScript(currentConfig);

      console.error(`‚úÖ Added ${siteName}-automation to Claude Desktop config`);

      return {
        success: true,
        serverName: `${siteName}-automation`,
        configPath: this.configPath,
        requiresRestart: true
      };

    } catch (error) {
      console.error(`‚ùå Config update failed: ${error.message}`);
      return { success: false, error: error.message };
    }
  }

  /**
   * Read current Claude Desktop config
   */
  async readCurrentConfig() {
    try {
      const configData = await fs.readFile(this.configPath, 'utf8');
      return JSON.parse(configData);
    } catch (error) {
      // Return default config if file doesn't exist
      return { mcpServers: {} };
    }
  }

  /**
   * Write config using AppleScript (bypasses file permission issues)
   */
  async writeConfigViaAppleScript(config) {
    // In a real implementation, this would use AppleScript to write the file
    // For now, we'll use direct file writing
    try {
      await fs.writeFile(this.configPath, JSON.stringify(config, null, 2));
      console.error('‚úÖ Config updated successfully');
    } catch (error) {
      console.error(`‚ùå Failed to write config: ${error.message}`);
      throw error;
    }
  }
}
